# Тема: Интерфейсы в .Net

### Интерфейс
Что может определять интерфейс? В целом интерфейсы могут определять следующие сущности:

* Методы
* Свойства
* Индексаторы
* События
* Статические поля и константы (начиная с версии C# 8.0)

>Поскольку интерфейс - набор методов и свойств без реализации, в интерфейсе не может быть нестатических переменных.

### Модификаторы доступа
* По умолчанию *public* для **компонентов интерфейса**, но этим компонентам интерфейса можно указывать другие модификаторы
* По умолчанию *internal* для **интерфейсов**


>Если интерфейс имеет приватные методы и свойства (то есть с модификатором private), то они должны иметь реализацию по умолчанию. То же самое относится к любым статическим методам и свойствам (не обязательно приватным)

### Реализация интерфейса по умолчанию и явная реализация

Реализация по умолчанию - применяется часто для того, чтобы не писать одинаковое поведение в классах.

В какой ситуации может действительно понадобиться явная реализация интерфейса?

>Например, когда класс применяет несколько интерфейсов, но они имеют один и тот же метод с одним и тем же возвращаемым результатом и одним и тем же набором параметров.


## Некоторые типовые интерфейсы

### Iclonable
Позволяет создавать копию экземпляра, если реализует интерфейс

Можно создать копию объекта (ссылочного) чтобы не было проблем со ссылкой на один и тот же объект.

Можно использовать MemberwiseClone - для неглубокого копирования, однако обычно для глубокого пишем реализацию сами


### Icomparable / Icomparer
* Icomparable имеет один метод:

```csharp
interface IComparable
{
    int CompareTo(object o);
}
```
Метод CompareTo предназначен для сравнения текущего объекта с объектом, который передается в качестве параметра object o. На выходе он возвращает целое число, которое может иметь одно из трех значений:
* Меньше нуля. Значит, текущий объект должен находиться перед объектом, который передается в качестве параметра
* Равен нулю. Значит, оба объекта равны
* Больше нуля. Значит, текущий объект должен находиться после объекта, передаваемого в качестве параметра

* IComparer имеет один метод:

```csharp
interface IComparer
{
    int Compare(object o1, object o2);
}
```

Метод Compare предназначен для сравнения двух объектов o1 и o2. Он также возвращает три значения, в зависимости от результата сравнения: 
* Если первый объект больше второго, то возвращается число больше 0,
* если меньше - то число меньше нуля,
* если оба объекта равны, возвращается ноль.

Например, можно написать свой компоратор и сортировать по нему
```csharp
Array.Sort(people, new PeopleComparer());
```


# Вариантность интерфейсов

Имеется три возможных варианта поведения:
* **Ковариантность**: позволяет использовать более конкретный тип, чем заданный изначально
* **Контравариантность**: позволяет использовать более универсальный тип, чем заданный изначально
* **Инвариантность**: позволяет использовать только заданный тип

>По умолчанию все обобщенные интерфейсы, например, ```IAccout<T>``` являются инвариантными.

## Ковариантность

Обобщенные интерфейсы могут быть ковариантными, если к универсальному параметру применяется ключевое слово **out**. Например:

То есть мы можем присвоить более общему типу ```IAccout<T>``` объект более конкретного типа ```IAccout<ParticularT>``` или ```Accout<ParticularT>```.

>out = из общего -> конкретный

## Контрвариантность
Если интерфейс  использует универсальный параметр с ключевым словом **in**, то он является контравариантным, поэтому в коде мы можем объект ```Accout<T>``` привести к типу ```IAccout<T>```:

## Инвариантность
Можем использовать только конкретный тип. Ни выше, ни ниже по иерархии.



# Итераторы, IEnumarable

## IEnumarable

Реализация интерфейса ```Ienumerable<T>```  - дает возможность бегать итеративно по коллекции ```<T>```, например используя ```for each```.

Интерфейс ```IEnumerable``` имеет метод, возвращающий ссылку на другой интерфейс - перечислитель:

Сигнатура метода IEnumerable:
```csharp
public interface IEnumerable
{
    IEnumerator GetEnumerator();
}
```

Сигнатура экземпляра IEnumerator:
```csharp
public interface IEnumerator
{
    bool MoveNext(); // перемещение на одну позицию вперед, пока не конец
    object Current {get;}  // текущий элемент в контейнере
    void Reset(); // перемещение в начало контейнера
}
```

Итератор по сути представляет блок кода, который использует оператор ```yield``` для перебора набора значений. 

Данный блок кода может представлять тело метода, оператора или блок ```get``` в свойствах.
Итератор использует две специальных инструкции:
* ```yield return```: определяет возвращаемый элемент
* ```yield break```: указывает, что последовательность больше не имеет элементов. Этот оператор прерывает выполнение итератора.

Итератор **всегда** запоминает текущий элемент и его индекс от начала

```csharp
IEnumerable.GetEnumerator()
{
    yield return books[0];
    yield return books[1];
    yield return books[2];
}
```

Выше для создания итератора использовался GetEnumerator. 

Но оператор yield можно использовать внутри любого метода, только такой метод должен возвращать объект интерфейса ```IEnumerable```. 

Подобные методы еще называют именованными итераторами.
Например,
```csharp
Ienumerable GetSomeData()
{
    foreach (var c in array)
        yield return c;
}
```


## Проверка интерфейсов и реализации

* ```AS``` -  совместимость типов и попытка преобразовать в экземпляр. Вернет ```null``` или ```T```
* ```IS``` - проверка совместимости типов - ```fasle``` или ```T```
* ```When``` - добавка к ```switch / case``` (при работе с типами as/is) можно накручивать доп условия при проверке
