# Расширенные средства языка C#

## Индексаторы

#### Дается возможность обращаться с экземпляром, как с коллекцией
```csharp
public Class this[T index]
    {
        get
        {
            return data[index];
        }
        set
        {
            data[index] = value;
        }
    }
```
 #### Ключ для класса может быть любого типа, а также класс может иметь многомерный индексатор.
```csharp
[T1 index 1, T2 index2, ...]
```

> Примером экземпляра с индексатором может быть IConfiguration


## Перегрузка операторов
#### Можно перегружать операторы
- Унарные (++, --, !)
- Бинарные (+, -, *)
- Сравнения (==, !=, <, >)


```csharp
public static T operator _OperatorLabel_(params)
{  }
```


## Преобразование типов
### Явная / неявная типизация
#### По умолчанию расширение типа делается неявно, т.е. следующий код отработает без проблем.

```csharp
int b;
long a = b;
```
#### Но можно и преобразовать тип явно, указывая явный тип преобразования

```csharp
int b;
var a = (long) b;
```

#### Для примитивов все очевидно, но мы можем создавать такие преобразования для своих классов
```csharp
public static implicit|explicit operator T(Base_T param)
```



## Extensions
#### Расширение поведения типа, который мы не можем менять. Метод прилинкуется к типу и появится возможность использовать свою реализацию метода. Важно, что в проекте нужно сделать ссылку на тип и на расширение, чтобы его использовать.

```csharp
public static class _{
    public static T Method(this _, params[]){ ...}
}
```



## Pointers
#### Работа с указателями на память, как в C++
> Нужно включить unsafe code опцию для проекта и обрамлять код в unsafe {...}

- (*) - переменная указателя
- (&) - адрес переменной
- (->) - внутреннее поле экземпляра
- ([]) - индексация памяти
- (++/+/==) - операции допустимы для указателей
- stackalloc - аллокация массива
- fixed - закрепление переменной после окончания выполнения
- sizeof - размер типа в байтах