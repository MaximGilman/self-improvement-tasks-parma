# Классические задачи теории множественных потоков

### Программу можно описать набором **состояний** в каждый конкретный момент.
### Процесс выполнения подразумевает последовательность операторов, которые состоят из **неделимых атомарных действий**.
### Последовательность состояний и действий формирует **историю или путь (*trace*)**.
<br>

## Два основных приема синхронизации:
- Mutual exclusion
    - Создание последовательности атомарных действий ```<a = b + c>```
- Conditional synchronization
    - Ожидание процессом какого-то условия ```<await (s > 0) -> s-->```
> В значках <..> здесь и далее отображается атомарная операция

<br>


## Классические задачи многопоточности:
### Задача критической секции (КС).
>Дано: N процессов которые работают внутри и вне КС. Нельзя допустить работу внутри КС потоков, больше определенного количества (в базовом виде не больше 1-го потока)

### Свойства задачи
1. Взаимное исключение из КС
1. Отсутствие взаимной блокировки КС
1. Отсутствие ожидания
1. Возможность входа

> Более научно, мы должны реализовать 3 правила:
- Security **(1)**
- Liveness **(2,3)**
- Fairness **(4)**

<br>

## Алгоритмы разрешения задачи КС
- Алгоритм Питерсона
    - Решение о том, кто зайдет в КС будет приниматься в зависимости от глоб. Переменной
```csharp
boolean in1 = true, in2 = false;
int last = 1;
process CS1 {
    while(true) {
        last = 1; in1 = true;
        < await (!in2 and last == 2) ; > // atomic 
        #region Crit
        ....
        in1 = false;
        #endregion
    }
}
process CS2 {
    while(true) {
        last = 2; in2 = true;
        < await (!in1 and last == 1) ; > // atomic 
        #region Crit
        ....
        in2 = false;
        #endregion
    }
}
```
- Алгоритм билета
    - Обращение к счетчику и получение номерка
    - Заходит самый маленький номер (или любой другой в зависимости от функции выбора)
    - Каждый выходящий поток "приглашает" поток со следующим ключем
```csharp
int number1 = 1, next1 = 1, turn[1:n];
process CS[i = 1 to n] {
    while(true) {
        turn[i] = FA(number, 1);
        while (turn[i] != next) skip;
        #region Crit
        ...
        next = next + 1;
        #endregion
    }
}
```
- Алгоритм поликлиники
    - Вместо обращения к общему счетчику процесс смотрит на максимальный номер
    - В остальном все аналогично тикетам

```csharp
int turn[1:n];
process CS[i = 1 to n] {
    while(true) {
        turn[i] = 1;
        turn[i] = max(turn[1:n] + 1);
        for [j = 1 to n where j != i]
            while (turn[j] != 0 and
                    (turn[i], i) > (turn[j], j)) skip;
        #region Crit
        ...        
        turn[i] = 0;
        #endregion
    }
}
```


<br>
<br>
<br>


# Барьеры
## Барьером называется точка в программе, преодолеть которую можно только дождавшись окончания всех потоков.
> Примером барьера может служить действие из Сетей Петри

<br>


![Сети Петри](https://studref.com/htm/img/15/6352/321.png)

<br>

## Синхронизация с управляющим процессом

### Реализуем эту задачу через массив ожидания и массив продолжения 
```csharp
int arrive[1:n], continue[1:n];
process Worker {
    while(true) {
        //do task i 
        arrive[i] = 1;
        < await (continue[i] == 1) ; > //atomic
        continue[i] = 0;
    }
}
process Coordinator {
    while(true) {
        for [i = 1 to n] {
            < await (arrive[i] == 1) ; > //atomic
            arrive[i] = 0;
        }
        for [i = 1 to n] continue[i] = 1;
    }
}
```
#### У даного подхода есть основная проблема: **мы тратим отдельный поток на синхронизацию вместо того, чтобы использовать его для вычислений**.

Другая проблема заключается в том, что **время преодоления каждого барьера пропорционально числу рабочих потоков**, так как координатор обходит их в цикле. Для решения этих проблем можно использовать древовидную структуру оповещения потоков. 

Тогда время будет пропорционально логарифму от числа потоков, но возникнет новая проблема: разные потоки выполняют разную работу при достижении барьера.

<br>

### Симметричные барьеры

#### Симметричный барьер для n процессов строится из пар простых двухпроцессорных барьеров. Пусть каждый процесс по достижении барьера устанавливает собственный флаг; тогда симметричный барьер для них выглядит так:

```Pl
# Фрагмент для барьера в W[i]
< await (arrive[i] == 0); >
arrive[i] = 1;
< await (arrive[j] == 1); >
arrive[j] = 0;

# Фрагмент для барьера в W[j]
< await (arrive[j] == 0); >
arrive[] = 1;
< await (arrive[i] == 1); >
arrive[i] = 0;
```
<br>

#### В общем случае строится дерево пар:
!['Барьеры'](https://alexeykalina.github.io/assets/img/2017-12-04/barrier1.png)

<br>

>В языке C# для решения этой задачи существует класс Barrier. 
Для использования этого класса необходимо:
- Создать экземпляр, указав количество потоков, которые будут встречаться одновременно (можно изменить это значение позднее путем вызова методов AddParticipants() / RemoveParticipants()).
- Каждый поток, ожидающий встречи, должен вызвать метод SignalAndWait().

<br>

## Семафоры

### Семафор - это обычная целочисленная неотрицательная переменная, с которой можно работать только с помощью двух специальных неделимых операций *P* и *V*. Для определения семафора используется ключевое слово *sem*. 
Пусть s - семафор, тогда операции P и V определяются следующим образом:
> ```P(s): <await (s > 0) s = s - 1>```

> ```V(s): s = s + 1```

Семафоры изначально обеспечивают взаимное исключение, поэтому с их помощью можно проще решить уже рассмотренные задачи.

### Критические секции
```csharp
sem mutex = 1;
process CS[i = 1 to n] {
    while(true) {

        P(mutex);
        #region Crit
        ...
        V(mutex);
        #endregion
    }
}
```
>Здесь используются двоичный семафор, то есть семафор, который может принимать только два значения - ноль и один. Такие семафоры принято называть мьютексами (mutex).

### Барьеры
Для организации барьера необходимо использовать массив мьютексов, по одному для каждого процесса.

```csharp
sem arrive1 = 0, arrive2 = 0;

process Worker1 {
    while(true) {
        ...
        V(arrive1);
        P(arrive2);
        ...
    }
}

process Worker2 {
    while(true) {
        ...
        V(arrive2);
        P(arrive1);
        ...
    }
}
```
<br>

## Очередь Производитель-Потребитель
По условию задачи есть общий буфер (разделяемый массив) и два вида потоков: первые пишут данные в буфер, вторые читают из него. 

Нужно организовать очередь обращений к буферу так, чтобы никакие из уже записанных данных не были утеряны (перезаписаны) и никакие не были прочитаны дважды.

```csharp
typeT buf[n];
int front = 0, rear = 0;
sem empty = n, full = 0;

process Producer {
    while(true) {
        P(empty);
        buf[rear] = data; 
        rear = (rear + 1) % n;
        V(full);
    }
}

process Consumer {
    while(true) {
        P(full);
        buf[rear] = data; 
        result = buf[front];
        front = (front + 1) % n;
        V(empty);
        ...
    }
}
```

<br>

## [Мой алгоритм для решения задачи светофоров](https://github.com/MaximGilman/Promela-traffic-verification)
- Данный подход позволяет потокам самим договариваться о порядке.
- Все потоки сидят в кругу, они знают соседей и соперников по ресурсу
- Потоки передают "листок" с общим списком желающих зайти в КС
- Каждый из желающих пишет свой номер
- Всегда выполняется максимальный номер
- Если поток "пропустил" вперед кого-то его значение увеличивается на константу **=N**
- При следующей проверке у тех кто пропускал других ранее будет приемущество

